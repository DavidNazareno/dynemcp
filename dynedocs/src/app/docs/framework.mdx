# Framework Guide

This guide covers the core concepts and architecture of the DyneMCP framework, helping you understand how to build sophisticated MCP servers.

## Architecture Overview

DyneMCP follows a modular architecture designed for scalability and maintainability:

```
DyneMCP Server
├── Configuration Layer      # dynemcp.config.json
├── Transport Layer          # stdio, HTTP, SSE
├── Registry System          # Dynamic component registration
├── Execution Engine         # Tool/Resource/Prompt handling
└── Build System            # esbuild-based bundling
```

## Core Concepts

### MCP Server

The MCP server is the heart of your application. It handles:

- **Protocol Communication**: Manages MCP protocol messages
- **Component Registry**: Registers and manages tools, resources, and prompts
- **Transport Management**: Handles different communication protocols
- **Lifecycle Management**: Server initialization and shutdown

```typescript
import { createMCPServer } from '@dynemcp/dynemcp'

const server = createMCPServer('my-server', './dynemcp.config.json', '1.0.0')

// Access server features
console.log(server.tools) // Registered tools
console.log(server.resources) // Registered resources
console.log(server.prompts) // Registered prompts
console.log(server.stats) // Server statistics
```

### Configuration System

DyneMCP uses a declarative configuration approach with `dynemcp.config.json`:

```json
{
  "name": "my-server",
  "version": "1.0.0",
  "description": "My MCP server",
  "transport": {
    "type": "stdio"
  },
  "build": {
    "outDir": "dist",
    "bundle": true,
    "minify": false
  },
  "security": {
    "cors": true,
    "rateLimit": {
      "requests": 100,
      "window": "15m"
    }
  }
}
```

## Component Types

### Tools

Tools are executable functions that the MCP client can call:

```typescript
import { DyneMCPTool } from '@dynemcp/dynemcp'
import { z } from 'zod'

export class FileReaderTool extends DyneMCPTool {
  get name() {
    return 'read_file'
  }

  readonly description = 'Reads content from a file'
  readonly schema = z.object({
    path: z.string().describe('File path to read'),
    encoding: z.enum(['utf8', 'base64']).default('utf8'),
  })

  async execute(input: z.infer<typeof this.schema>) {
    // Tool implementation
    const content = await fs.readFile(input.path, input.encoding)
    return { content, size: content.length }
  }
}
```

### Resources

Resources provide data that models can access:

```typescript
import { ResourceDefinition } from '@dynemcp/dynemcp'

export const apiDocsResource: ResourceDefinition = {
  uri: 'docs://api/v1',
  name: 'API Documentation',
  description: 'Complete API reference',
  content: async () => {
    // Dynamic content loading
    return await loadApiDocumentation()
  },
  contentType: 'text/markdown',
}
```

### Prompts

Prompts are reusable templates for model interactions:

```typescript
import { PromptDefinition } from '@dynemcp/dynemcp'

export const codeReviewPrompt: PromptDefinition = {
  id: 'code-review',
  name: 'Code Review Assistant',
  description: 'Provides code review feedback',
  content: `Review this code for:
- Best practices
- Performance issues
- Security concerns
- Code quality`,
  variables: {
    language: 'Programming language',
    complexity: 'Code complexity level',
  },
}
```

## Server Lifecycle

### Initialization Phase

1. **Configuration Loading**: Reads `dynemcp.config.json`
2. **Component Discovery**: Scans for tools, resources, and prompts
3. **Registry Population**: Registers discovered components
4. **Transport Setup**: Initializes the communication layer

```typescript
async function main() {
  const server = createMCPServer('my-server')

  // Initialize server
  await server.init()

  // Optional: Register additional components
  server.registerTool(new CustomTool())
  server.registerResource(customResource)

  // Start server
  await server.start()
}
```

### Runtime Phase

During runtime, the server:

- Processes incoming MCP messages
- Routes tool calls to appropriate handlers
- Manages resource access
- Handles prompt execution
- Maintains state and statistics

### Shutdown Phase

Clean shutdown ensures:

- Active connections are closed gracefully
- Resources are released properly
- Temporary files are cleaned up
- Final statistics are logged

## Transport Protocols

### stdio Transport

Perfect for command-line integration:

```json
{
  "transport": {
    "type": "stdio"
  }
}
```

### HTTP Transport

For web-based applications:

```json
{
  "transport": {
    "type": "http",
    "port": 3000,
    "host": "localhost",
    "cors": true
  }
}
```

### Server-Sent Events (SSE)

For real-time streaming:

```json
{
  "transport": {
    "type": "sse",
    "port": 3000,
    "endpoint": "/events"
  }
}
```

## Build System

DyneMCP uses esbuild for ultra-fast builds:

### Configuration Options

```json
{
  "build": {
    "outDir": "dist",
    "bundle": true,
    "minify": true,
    "sourcemap": false,
    "target": "node18",
    "external": ["@dynemcp/dynemcp"]
  }
}
```

### Advanced Build Features

- **Code Splitting**: Automatic code splitting for large applications
- **Tree Shaking**: Dead code elimination
- **Module Resolution**: Smart dependency resolution
- **Asset Bundling**: Static asset processing

## Performance Optimization

### Caching Strategy

DyneMCP implements intelligent caching:

```typescript
// Tool result caching
export class CachedTool extends DyneMCPTool {
  async execute(input: any) {
    const cacheKey = this.generateCacheKey(input)

    // Check cache first
    const cached = await this.cache.get(cacheKey)
    if (cached) return cached

    // Execute and cache result
    const result = await this.performWork(input)
    await this.cache.set(cacheKey, result, { ttl: 300 })

    return result
  }
}
```

### Memory Management

- **Lazy Loading**: Components are loaded on-demand
- **Memory Pools**: Efficient memory allocation
- **Garbage Collection**: Automatic cleanup of unused resources

### Monitoring

Built-in metrics collection:

```typescript
// Access server metrics
const stats = server.getStats()
console.log(stats.requestCount)
console.log(stats.averageResponseTime)
console.log(stats.errorRate)
```

## Security Features

### Authentication

Multiple authentication strategies:

```json
{
  "security": {
    "auth": {
      "type": "bearer",
      "secret": "your-secret-key"
    }
  }
}
```

### Rate Limiting

Prevent abuse with rate limiting:

```json
{
  "security": {
    "rateLimit": {
      "requests": 100,
      "window": "15m",
      "skipSuccessfulRequests": true
    }
  }
}
```

### Input Validation

Automatic input validation with Zod schemas:

```typescript
const schema = z.object({
  email: z.string().email(),
  age: z.number().min(0).max(150),
})

// Validation happens automatically
```

## Testing

### Unit Testing

DyneMCP provides testing utilities:

```typescript
import { createTestServer } from '@dynemcp/dynemcp/testing'

describe('MyTool', () => {
  it('should process input correctly', async () => {
    const server = createTestServer()
    server.registerTool(new MyTool())

    const result = await server.callTool('my-tool', { input: 'test' })
    expect(result).toEqual({ output: 'processed test' })
  })
})
```

### Integration Testing

End-to-end testing with real transports:

```typescript
import { createTestClient } from '@dynemcp/dynemcp/testing'

describe('Server Integration', () => {
  it('should handle full request cycle', async () => {
    const client = await createTestClient('./dynemcp.config.json')

    const tools = await client.getTools()
    expect(tools).toContain('my-tool')

    const result = await client.callTool('my-tool', { data: 'test' })
    expect(result.success).toBe(true)
  })
})
```

## Best Practices

### Project Structure

```
src/
├── tools/           # Tool implementations
│   ├── file-tools.ts
│   └── math-tools.ts
├── resources/       # Resource definitions
│   ├── docs.ts
│   └── data.ts
├── prompts/         # Prompt templates
│   ├── assistant.ts
│   └── review.ts
└── index.ts         # Server entry point
```

### Error Handling

Implement comprehensive error handling:

```typescript
export class RobustTool extends DyneMCPTool {
  async execute(input: any) {
    try {
      return await this.performWork(input)
    } catch (error) {
      this.logger.error('Tool execution failed', { error, input })
      throw new MCPError('TOOL_EXECUTION_FAILED', error.message)
    }
  }
}
```

### Logging

Use structured logging:

```typescript
import { logger } from '@dynemcp/dynemcp'

logger.info('Server started', {
  version: '1.0.0',
  transport: 'http',
  port: 3000,
})
```

### Configuration Management

Environment-specific configurations:

```json
{
  "extends": "./base.config.json",
  "environment": "production",
  "logging": {
    "level": "warn"
  }
}
```

## Next Steps

- [CLI Reference](/docs/cli) - Learn command-line tools
- [Templates](/docs/templates) - Explore pre-built templates
- [Tools Guide](/docs/tools) - Build custom tools
- [API Documentation](/api) - Complete API reference
