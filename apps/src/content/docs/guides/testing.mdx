---
title: Testing Guide
description: Guide for testing DyneMCP servers and tools
---

# Testing Guide

This guide covers testing strategies and best practices for DyneMCP servers and tools.

## Testing Setup

DyneMCP projects use Vitest for testing. Here's how to set up your testing environment:

### Vitest Configuration

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['src/**/*.{test,spec}.{js,ts}'],
  },
})
```

### Test Environment Setup

```typescript
// src/test/setup.ts
import { vi, beforeEach, afterEach } from 'vitest'
import { createMCPServer } from '@dynemcp/dynemcp'

// Mock console to avoid test output pollution
beforeEach(() => {
  vi.spyOn(console, 'log').mockImplementation(vi.fn())
  vi.spyOn(console, 'error').mockImplementation(vi.fn())
})

afterEach(() => {
  vi.restoreAllMocks()
})
```

## Tool Testing

### Basic Tool Test

```typescript
import { vi, describe, it, expect } from 'vitest'
import { createMCPServer } from '@dynemcp/dynemcp'
import type { ToolDefinition } from '@dynemcp/dynemcp'

describe('Calculator Tool', () => {
  const calculatorTool: ToolDefinition = {
    name: 'calculator',
    description: 'Basic calculator operations',
    schema: {
      type: 'object',
      properties: {
        operation: { type: 'string', enum: ['add', 'subtract'] },
        a: { type: 'number' },
        b: { type: 'number' },
      },
      required: ['operation', 'a', 'b'],
    },
    handler: async ({ operation, a, b }) => {
      switch (operation) {
        case 'add':
          return a + b
        case 'subtract':
          return a - b
        default:
          throw new Error('Invalid operation')
      }
    },
  }

  const server = createMCPServer()

  beforeEach(() => {
    server.registry.addTool(calculatorTool)
  })

  it('adds two numbers', async () => {
    const result = await server.execute('calculator', {
      operation: 'add',
      a: 2,
      b: 3,
    })

    expect(result).toBe(5)
  })

  it('validates input', async () => {
    await expect(
      server.execute('calculator', {
        operation: 'add',
        a: 'invalid',
        b: 3,
      })
    ).rejects.toThrow()
  })
})
```

### Testing with Dependencies

```typescript
import { vi, describe, it, expect } from 'vitest'
import { createMCPServer } from '@dynemcp/dynemcp'
import type { ToolDefinition, ResourceDefinition } from '@dynemcp/dynemcp'

describe('Tool with Dependencies', () => {
  const server = createMCPServer()

  // Mock dependent tool
  const mockBasicTool: ToolDefinition = {
    name: 'basic',
    description: 'Mock basic tool',
    schema: {
      type: 'object',
      properties: {
        input: { type: 'string' },
      },
    },
    handler: vi.fn().mockResolvedValue(42),
  }

  // Mock resource
  const mockResource: ResourceDefinition = {
    uri: 'data://test',
    name: 'Test Resource',
    content: { value: 10 },
  }

  beforeEach(() => {
    server.registry.addTool(mockBasicTool)
    server.registry.addResource(mockResource)
  })

  it('uses dependencies', async () => {
    const result = await server.execute('basic', {
      input: 'test',
    })

    expect(mockBasicTool.handler).toHaveBeenCalled()
    expect(result).toBe(42)
  })
})
```

## Server Testing

### Server Integration Tests

```typescript
import { vi, describe, it, expect } from 'vitest'
import { createMCPServer } from '@dynemcp/dynemcp'
import type { ToolDefinition } from '@dynemcp/dynemcp'

describe('Server Integration', () => {
  const greetTool: ToolDefinition = {
    name: 'greet',
    description: 'Greeting tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string' },
      },
      required: ['name'],
    },
    handler: async ({ name }) => `Hello, ${name}!`,
  }

  const server = createMCPServer('test-server')

  beforeAll(async () => {
    server.registry.addTool(greetTool)
    await server.init()
  })

  afterAll(async () => {
    await server.stop()
  })

  it('loads tools correctly', () => {
    expect(server.registry.tools.length).toBe(1)
  })

  it('executes tools', async () => {
    const result = await server.execute('greet', {
      name: 'Test',
    })

    expect(result).toBe('Hello, Test!')
  })
})
```

### Transport Testing

```typescript
import { vi, describe, it, expect } from 'vitest'
import { createMCPServer } from '@dynemcp/dynemcp'

describe('HTTP Stream Transport', () => {
  const server = createMCPServer('test-server', {
    transport: {
      type: 'http-stream',
      options: {
        port: 3000,
      },
    },
  })

  beforeAll(async () => {
    await server.init()
  })

  afterAll(async () => {
    await server.stop()
  })

  it('handles HTTP stream requests', async () => {
    const response = await fetch('http://localhost:3000/mcp', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        tool: 'greet',
        params: { name: 'Test' },
      }),
    })

    expect(response.ok).toBe(true)
    const result = await response.json()
    expect(result).toBeDefined()
  })
})
```

## Best Practices

1. **Isolation**: Test each tool in isolation
2. **Mocking**: Use Vitest's mocking capabilities
3. **Coverage**: Aim for high test coverage
4. **Error Cases**: Test error conditions
5. **Integration**: Include integration tests
6. **Configuration**: Test different configurations

## Running Tests

```bash
# Run all tests
pnpm test

# Run tests in watch mode
pnpm test:watch

# Run tests with coverage
pnpm test:coverage

# Run specific test file
pnpm test src/tools/calculator.test.ts
```

## Example Test Structure

```
src/
  ├── tools/
  │   ├── calculator.ts
  │   └── calculator.test.ts
  ├── resources/
  │   ├── data.ts
  │   └── data.test.ts
  └── test/
      ├── setup.ts
      └── integration/
          └── server.test.ts
```
