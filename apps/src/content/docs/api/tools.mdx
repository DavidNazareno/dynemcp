---
title: Tool API
description: Complete reference for creating and managing DyneMCP tools
---

# Tool API Reference

Tools are the core building blocks of DyneMCP servers. They provide the functionality that MCP clients can invoke.

## DyneMCPTool Class

The base class for creating tools in DyneMCP.

```typescript
abstract class DyneMCPTool {
  abstract get name(): string
  abstract readonly description: string
  abstract readonly schema: z.ZodType
  abstract execute(params: any): Promise<any>
}
```

### Required Properties

| Property      | Type        | Description                 |
| ------------- | ----------- | --------------------------- |
| `name`        | `string`    | Unique tool identifier      |
| `description` | `string`    | Tool description            |
| `schema`      | `z.ZodType` | Parameter validation schema |

### Methods

#### execute()

The main method that implements the tool's functionality.

```typescript
abstract execute(params: any): Promise<any>
```

## Creating Tools

### Class-based Approach

```typescript
import { DyneMCPTool } from '@dynemcp/dynemcp'
import { z } from 'zod'

export class CalculatorTool extends DyneMCPTool {
  get name() {
    return 'calculator'
  }

  readonly description = 'Performs basic math operations'

  readonly schema = z.object({
    operation: z.enum(['add', 'subtract', 'multiply', 'divide']),
    a: z.number(),
    b: z.number(),
  })

  async execute(params: z.infer<typeof this.schema>) {
    const { operation, a, b } = params

    switch (operation) {
      case 'add':
        return a + b
      case 'subtract':
        return a - b
      case 'multiply':
        return a * b
      case 'divide':
        if (b === 0) throw new Error('Division by zero')
        return a / b
    }
  }
}
```

### Function-based Approach

```typescript
import { createTool } from '@dynemcp/dynemcp'
import { z } from 'zod'

export const greetingTool = createTool({
  name: 'greet',
  description: 'Greets a person',
  schema: z.object({
    name: z.string(),
  }),
  execute: async ({ name }) => {
    return `Hello, ${name}!`
  },
})
```

## Tool Registration

Tools can be registered in several ways:

### 1. Auto-discovery

Place tools in the configured tools directory:

```
src/
  tools/
    calculator.ts
    greeting.ts
```

```json
{
  "tools": {
    "enabled": true,
    "directory": "./src/tools",
    "pattern": "**/*.{ts,js}"
  }
}
```

### 2. Manual Registration

```typescript
const server = createMCPServer()

// Register class-based tool
server.registry.registerTool(new CalculatorTool())

// Register function-based tool
server.registry.registerTool(greetingTool)
```

## Schema Validation

DyneMCP uses [Zod](https://github.com/colinhacks/zod) for parameter validation:

```typescript
import { z } from 'zod'

const schema = z.object({
  // String with min/max length
  name: z
    .string()
    .min(2, 'Name must be at least 2 characters')
    .max(50, 'Name must be at most 50 characters'),

  // Number with range
  age: z
    .number()
    .int('Age must be an integer')
    .min(0, 'Age must be positive')
    .max(150, 'Age must be realistic'),

  // Optional field
  email: z.string().email('Invalid email format').optional(),

  // Enum
  role: z.enum(['user', 'admin']),

  // Array
  tags: z.array(z.string()),

  // Nested object
  address: z.object({
    street: z.string(),
    city: z.string(),
    country: z.string(),
  }),
})
```

## Error Handling

Tools should handle errors appropriately:

```typescript
export class DivisionTool extends DyneMCPTool {
  get name() {
    return 'divide'
  }

  readonly description = 'Divides two numbers'

  readonly schema = z.object({
    dividend: z.number(),
    divisor: z.number(),
  })

  async execute({ dividend, divisor }) {
    try {
      // Input validation
      if (divisor === 0) {
        throw new Error('Division by zero is not allowed')
      }

      // Perform operation
      const result = dividend / divisor

      // Check for special cases
      if (!Number.isFinite(result)) {
        throw new Error('Result is not a finite number')
      }

      return result
    } catch (error) {
      // Log error for debugging
      console.error('Division error:', error)

      // Rethrow with user-friendly message
      throw new Error(`Failed to perform division: ${error.message}`)
    }
  }
}
```

## Best Practices

1. **Input Validation**

   - Always validate input parameters
   - Use descriptive error messages
   - Handle edge cases

2. **Error Handling**

   - Use try-catch blocks
   - Provide meaningful error messages
   - Log errors for debugging

3. **Performance**

   - Keep tools focused and simple
   - Avoid unnecessary async operations
   - Cache expensive computations

4. **Documentation**
   - Document tool purpose
   - Describe parameters
   - Provide usage examples

## Examples

### Async Tool

```typescript
export class WeatherTool extends DyneMCPTool {
  get name() {
    return 'weather'
  }

  readonly description = 'Gets weather for a location'

  readonly schema = z.object({
    city: z.string(),
    country: z.string(),
  })

  async execute({ city, country }) {
    try {
      const response = await fetch(`https://api.weather.com/${city},${country}`)

      if (!response.ok) {
        throw new Error('Weather API error')
      }

      return await response.json()
    } catch (error) {
      throw new Error(`Weather lookup failed: ${error.message}`)
    }
  }
}
```

### Stateful Tool

```typescript
export class CounterTool extends DyneMCPTool {
  private count = 0

  get name() {
    return 'counter'
  }

  readonly description = 'Maintains a counter'

  readonly schema = z.object({
    action: z.enum(['increment', 'decrement', 'reset', 'get']),
  })

  async execute({ action }) {
    switch (action) {
      case 'increment':
        return ++this.count
      case 'decrement':
        return --this.count
      case 'reset':
        this.count = 0
        return this.count
      case 'get':
        return this.count
    }
  }
}
```
